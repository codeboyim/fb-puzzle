<!DOCTYPE html>
<html>

<head>
    <title>Hello React</title>

    <script src="/scripts/console-polyfill.js"></script>
    <script src="/scripts/es5-shim.min.js"></script>
    <script src="/scripts/es5-sham.min.js"></script>
    <script src="/scripts/moment.min.js"></script>
    <!-- <script src="http://fb.me/react-0.5.1.js"></script>
    <script src="http://fb.me/JSXTransformer-0.5.1.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js"></script>  
    <script src="//codeorigin.jquery.com/jquery-1.10.2.js"></script> -->

    <script>
    var GLOBAL_VARS = {};
    </script>
    <style>
    body {
        font-family:'lucida grande', tahoma, verdana, arial, sans-serif;
        font-size:11px;
    }
    .singleDayCal {
        display:inline-block;
        color:#797979;
    }
    .singleDayCal:after {
        content:'.';
        clear:both;
        display:block;
        visibility: hidden;
        height:0;
        line-height: 0ï¼›
    }
    .singleDayCal-day {
        width:600px;
        padding: 0 10px;
        height:720px;
        position:relative;
        background-color:#ececec;
        float:left;
    }
    .singleDayCal-event {
        position:absolute;
        vertical-align: top;
        display:inline-block;
        border-left:4px solid #4b6ea9;
        overflow:hidden;
        margin:0;
        padding:0;
        top:0;
        left:0;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
    }
    .singleDayCal-event .content {
        background-color:white;
        overflow:hidden;
        border:solid 1px #d5d5d5;
        border-left:none;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
    }
    .singleDayCal-event .header {
        color:#4b6ea8;
        font-size:12px;
        margin:5px 0 0 5px;
        padding:0;
    }
    .singleDayCal-event .body {
        font-size:9px;
        margin:0 5px;
        padding:0;
    }
    .singleDayCal-times {
        width: 75px;
        margin:0 10px 0 0;
        padding:0;
        float:left;
        height:720px;
        text-align:right;
        position:relative;
        font-size:9px;
        color:#a7a7a7;
        list-style:none;
        top:-5px;
    }
    .singleDayCal-times li {
        padding:0;
        margin:0;
        position:absolute;
        width:100%;
    }
    .singleDayCal-times em {
        color:#686868;
        font-style:normal;
        font-size:12px;
        font-weight:bold;
        margin-right:5px;
    }
    #container {
        padding:10px;
    }
    </style>
    <!--[if lt IE 8]>
    <style>
    .singleDayCal {
        display:inline-block;
    }
    .singleDayCal-event {
        height:1%;
    }
    </style>
    <script>
        GLOBAL_VARS.isLtIE8=true;
    </script>
    <![endif]-->

</head>

<body>
    <div id="container">

    </div>

    <script>
    var events = [{
        start: 90,
        end: 150
    }, {
        start: 260,
        end: 280
    }, {
        start: 80,
        end: 140
    }, {
        start: 210,
        end: 250
    }, {
        start: 210,
        end: 220
    }, {
        start: 165,
        end: 450
    }, {
        start: 160,
        end: 300
    }, {
        start: 180,
        end: 220
    }, {
        start: 175,
        end: 270
    }, {
        start: 240,
        end: 242
    }, {
        start: 180,
        end: 200
    }, {
        start: 350,
        end: 500
    }, {
        start: 400,
        end: 500
    }, {
        start: 550,
        end: 600
    }, {
        start: 580,
        end: 650
    }, {
        start: 590,
        end: 720
    }];


    var SingleDayCal = (function(exports) {
        'use strict';

        var minStart = 0,
            maxEnd = 720,
            startHour = 9,
            endHour = 21,
            timeInterval = 30,
            isLtIE8 = GLOBAL_VARS.isLtIE8 || false,
            eventIEOffset = !isLtIE8 ? null : {
                // offset for width/height in IE 6/7
                x: 4,
                y: 14
            },
            defaultContainer = document.getElementById('container'),
            eventTemplate = '<div class="singleDayCal-event"><div class="content"><h2 class="header">Sample Item</h2><p class="body">Sample Location</p></div></div>';

        /*
            helper functions
        */

        function getComputedStyle(elm) {
            return window.getComputedStyle ? window.getComputedStyle(elm) : elm.currentStyle;
        }

        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }


        /*
            EventList: a structure to keep events in same colliding group
        */

        var EventList = function(event) {

            if (typeof(event) !== 'undefined' && event !== null) {

                if (!isNumeric(event.start) || !isNumeric(event.end)) {
                    throw new Error('EventList: argument \'event\' must have numeric start and end values.');
                }

                this.event = event;
                this.next = null;
            }

        }

        EventList.prototype = {

            add: function(event) {

                var current = this;

                if (typeof(event) === 'undefined' || event === null) {
                    throw new Error('EventList.add(): argument \'event\' must not be undefined or null.');
                }

                if (!isNumeric(event.start) || !isNumeric(event.end)) {
                    throw new Error('EventList.add(): argument \'event\ must have numeric start and end values.');
                }

                if (!current.event) {

                    current.event = event;

                } else {

                    while (current.next) {
                        current = current.next;
                    }

                    current.next = {
                        event: event,
                        next: null
                    }

                }

                return event;
            }
        };


        /*
            rectifyEvent: validate and correct 'event' object
         */

        function rectifyEvent(event) {

            var tmp;

            if (event.start > event.end) {
                tmp = event.end;
                event.end = event.start;
                event.start = tmp;
            }

            if (event.start < minStart) {
                event.start = minStart;
            }

            if (event.end > maxEnd) {
                event.end = maxEnd;
            }

        }


        /*
            compareEvents: compare function for sorting
        */

        function compareEvents(event1, event2) {

            return event1.start - event2.start;

        }


        /*
            sortEventsIntoReversedGroups: sort events by starting time and group colliding events. it
            returns reversed groups with latest inserted group in the most front.
        */

        function sortEventsIntoReversedGroups(events) {

            var groups = [],
                eventList,
                event,
                current,
                group,
                eventAdded = false,
                collideCount = 0,
                groupEventListCurrent,
                groupEvent,
                i;

            if (!Array.isArray(events) || !events.length) {
                return groups;
            }

            events.sort(compareEvents);

            eventList = new EventList();

            events.forEach(function(event) {
                eventList.add(event);
            });

            current = eventList;
            i = 0;

            while (current && current.event) {

                event = current.event;
                eventAdded = false;

                // validate and rectify event
                rectifyEvent(event);

                if (i === 0) {
                    // init a group
                    group = {
                        eventList: new EventList(event),
                        // store all the indexes of colliding events
                        maxCollidingCount: 1
                        // store the max number of colliding events of the group. default to 1 if no other event in the same group
                    };

                    groups.unshift(group);

                } else {
                    // find last added group
                    group = groups[0];

                    // find if colliding with any events in the group
                    groupEventListCurrent = group.eventList;
                    groupEvent = groupEventListCurrent.event;
                    collideCount = 1;

                    while (groupEvent && event != groupEvent) {

                        if (event.start <= groupEvent.end) {

                            if (!eventAdded) {
                                group.eventList.add(event);
                                eventAdded = true;
                            }

                            collideCount++;
                        }

                        groupEventListCurrent = groupEventListCurrent ? groupEventListCurrent.next : null;
                        groupEvent = groupEventListCurrent ? groupEventListCurrent.event : null;

                    }

                    if (collideCount === 1) {
                        //no collding happens, create a new group
                        group = {
                            eventList: new EventList(event),
                            maxCollidingCount: 1
                        };

                        groups.unshift(group);

                    } else if (collideCount > group.maxCollidingCount) {

                        group.maxCollidingCount = collideCount;

                    }

                }

                current = current.next;

                i++;
            }

            return groups;
        }


        /*
            renderEvents: attach all groups to container
        */

        function renderEvents(reversedGroups, container) {

            var containerComputedCss,
                totalWidth,
                containerPaddingLeft,
                groupsLen = 0,
                i = 0,
                groupWrapper,
                elmDay = document.createElement('div');

            elmDay.className = 'singleDayCal-day';
            container.appendChild(elmDay);

            containerComputedCss = getComputedStyle(elmDay);
            totalWidth = parseInt(containerComputedCss.width) || 0;
            containerPaddingLeft = parseInt(containerComputedCss.paddingLeft) || 0;
            reversedGroups = !Array.isArray(reversedGroups) ? [] : reversedGroups;
            groupsLen = reversedGroups.length;

            for (i = groupsLen - 1; i >= 0; i--) {
                renderGroup(reversedGroups[i], totalWidth, containerPaddingLeft, elmDay);
            }



            return elmDay;
        }


        /*
            renderGroup: attach a group to container
        */

        function renderGroup(group, totalWidth, containerPaddingLeft, container) {

            var eventWidth = Math.round(totalWidth / group.maxCollidingCount),
                //all events in the same colliding group will have same width according to 2)
                eventStacks = new Array(group.maxCollidingCount),
                //store the latest end value of each stack
                current = group.eventList,
                groupElm = document.createDocumentFragment(),
                event,
                elm,
                colIndex = 0,
                i = 0,
                j = 0;


            while (current) {

                event = current.event;
                elm = createEventElement(event, eventWidth);
                colIndex = i % (group.maxCollidingCount);

                if (eventStacks[colIndex] && eventStacks[colIndex] > event.start) {
                    //only to seek another stack when current stack doesn't fit
                    //events scatter better and there are less loops.

                    for (j = 0; j < group.maxCollidingCount; j++) {

                        if (eventStacks[j] <= event.start) {
                            eventStacks[j] = event.end;
                            elm.style.left = (containerPaddingLeft + j * eventWidth) + 'px';
                            break;
                        }

                    }

                } else {

                    eventStacks[colIndex] = event.end;
                    elm.style.left = (containerPaddingLeft + colIndex * eventWidth) + 'px';
                }

                groupElm.appendChild(elm);
                current = current.next;
                i++;
            }

            container.appendChild(groupElm);

            return groupElm;
        }


        /*
            createEventElement: create a html dom element for 'event' object
        */

        function createEventElement(event, width) {

            var eventElm,
                tmpElm,
                height = event.end - event.start - (eventIEOffset ? eventIEOffset.y : 0),
                width = width - (eventIEOffset ? eventIEOffset.x : 0);

            tmpElm = document.createElement('div');
            tmpElm.innerHTML = eventTemplate;
            eventElm = tmpElm.firstChild;
            eventElm.style.top = event.start + 'px';
            eventElm.style.width = width + 'px';
            eventElm.firstChild.style.height = height + 'px';

            //TO REMOVE
            eventElm.setAttribute('title', event.start + ' - ' + event.end);

            return eventElm;
        }

        /*
            renderTimeIntervals: display times - axis y
        */

        function renderTimeIntervals(container) {

            var elmTimeTicks = document.createElement('ul'),
                ticksCount = Math.ceil((endHour - startHour) * 60 / timeInterval) + 1,
                i,
                tickHtml = '',
                tm = moment(),
                mins,
                top;


            elmTimeTicks.className = 'singleDayCal-times';
            tm.hour(startHour);
            tm.minute(0);

            for (i = 0; i < ticksCount; i++) {

                mins = i * timeInterval;
                top = mins;

                if (mins % 60 === 0) {
                    tickHtml += '<li style="top: ' + top + 'px"><em>' + tm.format('h:mm') + '</em>' + tm.format('A') + '</li>';
                } else {
                    tickHtml += '<li style="top: ' + top + 'px">' + tm.format('h:mm') + '</li>';
                }

                tm.add('m', timeInterval);

            }

            elmTimeTicks.innerHTML = tickHtml;
            container.appendChild(elmTimeTicks);


            return elmTimeTicks;
        }


        /*
            SingleDayCal: public class to load and display a list of events in a single day calendar 
        */

        var SingleDayCal = function(events, container) {

            this._events = events;
            this._container = container || defaultContainer;

            if (!Array.isArray(this._events)) {
                throw new Error('SingleDayCal(): argument \'events\' must be an array.')
            }

            if (!this._container || !this._container.tagName) {
                throw new Error('SingleDayCal(): argument \'container\' must be a html dom element.')
            }


        };

        SingleDayCal.prototype = {

            layOutDay: function() {

                var wrapper = document.createElement('div');

                wrapper.className = 'singleDayCal';
                this._container.innerHTML = '';
                this._container.appendChild(wrapper);

                renderTimeIntervals(wrapper)
                renderEvents(sortEventsIntoReversedGroups(this._events), wrapper);

                return this;
            }

        }


        /*
            layOutDay: public interface to invoke SingleDayCal class and display events
        */
        exports.layOutDay = function(events) {

            var cal = new SingleDayCal(events);

            cal.layOutDay();

            return events.length;
        }

        return SingleDayCal;

    })(this);



    layOutDay(events);
    </script>

    <div id="content"></div>
    <script type="text/jsx">
    // /**
    //  * @jsx React.DOM
    //  */

    // var CommentBox = React.createClass({
    //         render: function() {
    //             return ( < div className = "commentBox" > < h1 > Comments < /h1>
    //         <CommentList data={this.props.data} / > < CommentForm / > < /div>
    //     );
    //   }
    // });

    // var CommentList = React.createClass({
    //   render:function(){
    //     var commentNodes = this.props.data.map(function(comment){
    //       return <Comment author={comment.author}>{comment.text}</Comment >
    //             });
    //         return ( < div className = "commentList" > {
    //             commentNodes
    //         } < /div>
    //     );
    //   }
    // });

    // var CommentForm = React.createClass({
    //   render: function(){
    //     return (
    //       <div className="commentForm">
    //         Hello, world! I am a CommentForm.
    //       </div > );
    //     }
    // });

    // var converter = new Showdown.converter();
    // var Comment = React.createClass({
    //         render: function() {
    //             var rawMarkup = converter.makeHtml(this.props.children.toString());
    //             return ( < div className = "comment" > < h2 className = "commentAuthor" > {
    //                     this.props.author
    //                 } < /h2>
    //         <span dangerouslySetInnerHTML={{__html: rawMarkup}} / > < /div>
    //     );
    //   }
    // });

    // var data = [
    //   {author: "Pete Hunt", text: "This is one comment"},
    //   {author: "Jordan Walke", text: "This is *another* comment"},
    // ];


    // React.renderComponent(
    //   <CommentBox data={data} / > ,
    //                 document.getElementById('content')
    //             );
    </script>
</body>

</html>
